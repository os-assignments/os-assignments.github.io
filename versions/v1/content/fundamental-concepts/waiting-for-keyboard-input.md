---
title: Waiting for keyboard input
weight: 35
draft: false
---

Humans are very slow compared to the CPU. No matter how fast you are,
the CPU will be able to execute a huge number of instructions between every
key-press you make.

* How can we make the CPU wait for a human user to press a key on the
  keyboard?
* Is it possible to make the CPU do something useful while waiting for user
  input?

## Polling 

To detect a key-press, one option is to repeatedly check the state of the input
device until the device has detected a key press. Usually such a device will use
one bit in a special device register to signal whether no input has occurred
(bit = 0) or if new input is available (bit = 1).

**Polling** refers to actively sampling the status of an external device at
regular intervals. Polling requires the use of the CPU to check the status of an
external device. Polling also refers to the situation where a device is
repeatedly checked for readiness, and if it is not the computer returns to a
different task between checking the status. 

Polling is most often used in terms of input/output (I/O), and is also referred
to as **polled I/O** or **software driven I/O**.

More generally, polling can be summarized as follows. 

<ol>
<li> A program cannot proceed until an external device becomes ready.</li>
<li> The program checks the status of the external device.</li>
  <ol type="A">
     <li>If the device is not ready, the program either:</li>
        <ol type="i">
          <li>
          Do some work not depending on the status of the device for a short amount
          of time, then go back to step 2.
          </li>
          <li>
          Gives the CPU to another program, and then when the operating system gives
          it the CPU back again, go back to step 2.
          </li>
        </ol>
     <li>The device is now ready, go to step 3.</li>
  </ol>   
<li>The program can now proceed and take appropriate action. </li>
</ol> 

## Busy waiting

If the program continuously polls the device without doing anything in between
checks, it's called a **busy-waiting**. 

Repeatedly checking the status of the input device require the use of the CPU.
Using a conditional loop the CPU can repeatedly load the value of the status
register to check if new input is available. While waiting for input the CPU
doesn't do any other work, the CPU is busy-waiting. 

{{% notice style="info" title="Polling â‰  Busy-Waiting" %}}

The term polling is sometimes used synonymously with busy-waiting but you
should be aware of the differences between polling and busy-waiting.

{{% /notice %}}

## Interrupts

**Interrupts** are used to signal events **external** to the program (timers,
serial ports, keyboard input etc). Interrupts are generated by other hardware
devices outside the CPU at arbitrary times with respect to the CPU clock signals
and are therefore considered to be **asynchronous**. 

A user program executes in user mode (text segment). When an interrupt happens,
control is automatically transferred to the interrupt handler executing in
kernel mode (ktext segment). 


An alternative to both polling and busy-waiting is to make the input device
generate an interrupt every time new input is available. Using interrupts makes
it possible for the CPU to do something useful, for example execute
another program, while waiting for user input.

![](/images/module-1/keyboard-interrupt-handling.png)


